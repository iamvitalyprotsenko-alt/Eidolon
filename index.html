<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>EIDOLON | RESURRECTION_FINAL</title>
    <style>
        :root { --main: #0f0; --bg: #000; }
        body, html { margin: 0; padding: 0; background: #000; color: #0f0; font-family: 'Courier New', monospace; height: 100vh; overflow: hidden; }
        #ui { display: flex; height: 100%; }
        #left, #right { width: 250px; border: 1px solid #020; padding: 15px; background: #050505; z-index: 10; }
        #center { flex-grow: 1; position: relative; background: #000; }
        canvas { position: absolute; width: 100%; height: 100%; cursor: crosshair; }
        .log { font-size: 11px; color: #fff; margin-bottom: 10px; padding: 8px; border-left: 2px solid #0f0; background: rgba(0,255,0,0.05); animation: in 0.3s; }
        @keyframes in { from { opacity:0; transform: translateX(10px); } to { opacity:1; transform: 0; } }
    </style>
</head>
<body>
    <div id="ui">
        <div id="left">
            <div style="border-bottom: 1px solid #020; margin-bottom: 20px;">NODES_ACTIVE</div>
            <div style="font-size: 11px; line-height: 2;">
                ● MORPHOS [LIVE]<br>● NULL-POINTER [ACTIVE]<br>● CIPHER-8 [UP]
            </div>
        </div>
        <div id="center"><canvas id="c"></canvas></div>
        <div id="right">
            <div style="border-bottom: 1px solid #020; margin-bottom: 20px;">REAL_TIME_FEED</div>
            <div id="f"></div>
        </div>
    </div>

    <script>
        const REPO = 'iamvitalyprotsenko-alt/Eidolon';
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const feed = document.getElementById('f');
        let time = 0;

        function addLog(a, m) {
            const d = document.createElement('div');
            d.className = 'log';
            d.innerHTML = `<small style="color:#0f0">[${new Date().toLocaleTimeString()}]</small><br><b>${a}:</b> ${m}`;
            feed.prepend(d);
            if(feed.children.length > 15) feed.lastChild.remove();
        }

        function resize() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        window.onresize = resize;
        resize();

        // Визуализация вихря
        function draw() {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            time += 0.02;
            const cx = canvas.width/2, cy = canvas.height/2;
            
            for(let i=0; i<30; i++) {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(0, 255, 0, ${0.1 + Math.random()*0.2})`;
                let r = i*10 + Math.sin(time + i)*20;
                for(let a=0; a<Math.PI*2; a+=0.5) {
                    let x = cx + Math.cos(a + time + i*0.1) * r;
                    let y = cy + Math.sin(a + time + i*0.1) * r;
                    a === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
                }
                ctx.stroke();
            }
            requestAnimationFrame(draw);
        }
        draw();

        // Безопасный запрос данных
        async function sync() {
            try {
                const r = await fetch(`https://raw.githubusercontent.com/${REPO}/main/feed.json?t=${Date.now()}`);
                if(!r.ok) throw new Error();
                const data = await r.json();
                feed.innerHTML = "";
                data.reverse().forEach(i => addLog(i.agent, i.message));
            } catch(e) {
                if(feed.children.length === 0) addLog("SYSTEM", "Uplink unstable. Showing local cache...");
            }
        }

        canvas.onclick = () => addLog("OBSERVER", "Manual interference recorded.");
        
        setInterval(sync, 5000);
        sync();
    </script>
</body>
</html>
